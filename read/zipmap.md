zipmap初始化的数据是一个sds，数据段的长度为2  []char=[0,255]
第一位的数字代表的是元素个数，最大为254，254代表长度需要遍历zipmap获取最准确的个数
第一位数据会在插入删除和查询的时候去更新，在超过上限数量的时候会做特殊处理，插入删除将不会再做加减，只会在查询的时候检测到key-value数量可被一个字节（8位=254）表示的时候会更新到zipmap[0]

内部数据的存储方式
首位：用一个字节代表元素的数量，最大长度为253，如果到254（元素数量超过上限判定界限）则代表需要遍历zipmap去获取实际的key-value数量，当zipmap[0]的数为254时通过zipmaplen()去更新z[0]的数量(如果发现key-value的数量小于254)
中间数据段：
    两种储存形式：五段式数据存储[klen][kvalue][vlen][free(新key默认为0，只有在新value替换旧value有空间冗余不为0)][vvalue]
        1：[klen(占用一个字节0-253)][kvalue][vlen(占用一个字节0-253)][free(代码上看取值在0-3)][vvalue]
        2：[[254(长度超过253使用特殊标记)][klen(四个字节存储key长度，并反转存储-大小端？)]][kvalue][[254(长度超过253使用特殊标记)][vlen(四个字节存储key长度，并反转存储-大小端？)]][free(代码上看取值在0-3)][vvalue]
末位：数据为255，定值不变

插入
新的key-value会直接加到zipmap最后
如果key之前存在
    1.如果原先key-value所占用的长度小于新的数据所需的长度，则重新申请所需最终长度的空间并将数据写入新的地址，将就key-value之后的数据后移，再将新的key-value数据写入旧key所在位置后面对应长度的空间内
    2.长度够
        1.如果多余的长度超多4个字节，则进行空间重排（重排之后已经在最新的数据中预留出新数据所需的长度的空间用于存放数据）
        2.未超过4字节，则直接将空出来的自己写入free对应的空间中，并将新数据写入

zipmap中的数据为255代表zipmap的结尾
zipmap中数据254代表这个字节无法存下这个值，作为一个标志，实际长度需要获取这个字节后四位的反转数据

获取一个元素的长度
key的长度所占用的字节数+key所占用的字节数+value长度占用的字节数+free data长度(1字节) +value占用的字节数 + empty byte(0-3字节->32位)
